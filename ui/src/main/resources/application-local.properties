app.version=@app.version@

# Spring datasource
app.sqlite.path=${APP_SQLLITE_PATH}

spring.datasource.mysql.url=${SPRING.DATASOURCE.MYSQL.URL}
spring.datasource.mysql.driver-class-name=${SPRING.DATASOURCE.MYSQL.DRIVER-CLASS-NAME}
spring.datasource.sqlite.url=${SPRING.DATASOURCE.SQLITE.URL}
spring.datasource.sqlite.driver-class-name=${SPRING.DATASOURCE.SQLITE.DRIVER-CLASS-NAME}
spring.datasource.mysql.username=${SPRING.DATASOURCE.MYSQL.USERNAME}
spring.datasource.mysql.password=${SPRING.DATASOURCE.MYSQL.PASSWORD}
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.transaction.coordinator_class=jdbc
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.hbm2ddl.auto=update
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true
spring.jpa.properties.hibernate.boot.allow_jdbc_metadata_access=false
spring.liquibase.url=${SPRING.LIQUIBASE.URL}
spring.liquibase.user=${SPRING.LIQUIBASE.USER}
spring.liquibase.password=${SPRING.LIQUIBASE.PASSWORD}
spring.liquibase.change-log=${SPRING.LIQUIBASE.CHANGE-LOG}
spring.liquibase.enabled=${SPRING.LIQUIBASE.ENABLED}
spring.liquibase.driver-class-name=${SPRING.LIQUIBASE.DRIVER-CLASS-NAME}
spring.jpa.defer-datasource-initialization=false
spring.main.allow-circular-references=true
app.telegram_bot.token=${APP.TELEGRAM_BOT.TOKEN}
app.telegram_chat_id=${APP.TELEGRAM_CHAT_ID}
app.telegram_thread_ping_id=${APP.TELEGRAM_THREAD_PING_ID}
app.telegram_thread_request_id=${APP.TELEGRAM_THREAD_REQUEST_ID}
# Spring encoding
spring.messages.encoding=UTF-8
server.servlet.encoding.charset=UTF-8
server.servlet.encoding.enabled=true
server.servlet.encoding.force=true
server.servlet.session.timeout=30m
server.tomcat.uri-encoding=UTF-8
spring.main.allow-bean-definition-overriding=true
# app
eve.authorize.uri=https://login.eveonline.com/v2/oauth/authorize
eve.character.portrait.url=https://images.evetech.net/characters/%s/portrait
eve.character.assets.url=/v5/characters/{characterId}/assets/
eve.character.uri=https://esi.evetech.net/latest/characters/%s/
eve.clientId=${EVE.CLIENTID}
eve.clientSecret=${EVE.CLIENTSECRET}
eve.corporation.info=/v5/corporations/{corporation_id}/
eve.alliance.info=/v3/alliances/{alliance_id}/
eve.mail.send.url=/latest/characters/{characterId}/mail/
eve.redirectUri=${EVE.REDIRECTURI}
eve.token.uri=https://login.eveonline.com/v2/oauth/token
eve.user-info.uri=https://esi.evetech.net/verify/
eve.webclient.baseUrl=https://esi.evetech.net
# OAuth2
spring.security.oauth2.client.registration.eveonline.client-id=${EVE.CLIENTID}
spring.security.oauth2.client.registration.eveonline.client-secret=${EVE.CLIENTSECRET}
spring.security.oauth2.client.registration.eveonline.scope=publicData
spring.security.oauth2.client.registration.eveonline.authorization-grant-type=authorization_code
spring.security.oauth2.client.registration.eveonline.redirect-uri=${eve.redirectUri}
spring.security.oauth2.client.registration.eveonline.client-name=EVE Online
#  OAuth2 (EVE API)
spring.security.oauth2.client.provider.eveonline.authorization-uri=${eve.authorize.uri}
spring.security.oauth2.client.provider.eveonline.token-uri=${eve.token.uri}
spring.security.oauth2.client.provider.eveonline.user-info-uri=${eve.user-info.uri}
spring.security.oauth2.client.provider.eveonline.user-name-attribute=CharacterName

vaadin.productionMode=${VAADIN.PRODUCTIONMODE}

timrod.api.url=https://service.scan-stakan.com/api/auth/checkUserByGroup.php
timrod.api.token=${TIMROD_API_TOKEN}
timrod.api.group-id=${TIMROD_API_GROUP_ID}

logging.level.org.springframework.transaction.interceptor=INFO
logging.level.org.springframework.orm.jpa=INFO
